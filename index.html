<!DOCTYPE html><html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>UTC World Clock</title>
  <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
  <style>
    /* SVG label text uses currentColor; we flip via JS */
    .arc-label { font: 12px/1.2 system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans", sans-serif; }
  </style>
</head>
<body class="min-h-screen bg-slate-100 text-slate-900 transition-colors">
  <div class="mx-auto max-w-xl p-6 sm:p-10">
    <header class="flex items-center justify-between gap-3">
      <div class="text-sm text-slate-500">Universal Time (UTC)</div>
      <label class="inline-flex items-center gap-2 cursor-pointer select-none">
        <input id="fmtToggle" type="checkbox" class="appearance-none w-10 h-6 rounded-full bg-slate-300 relative transition-all outline-none">
        <span id="fmtLabel" class="text-sm text-slate-600">24‑hour</span>
      </label>
    </header><main class="mt-6">
  <div class="text-center">
    <div id="utcTime" class="text-5xl sm:text-6xl font-semibold tracking-tight tabular-nums">00:00:00</div>
    <div class="mt-1 text-sm text-slate-500">Same everywhere • <span id="tzName">UTC</span></div>
  </div>

  <section class="mt-8 rounded-2xl p-5 sm:p-6 shadow-lg bg-white/70 backdrop-blur border border-slate-200">
    <div class="flex items-center justify-between text-xs text-slate-500">
      <div>Location: <span id="locLabel">Detecting…</span></div>
      <div id="dayState">—</div>
    </div>

    <div class="mt-4 relative">
      <!-- SVG semicircle canvas -->
      <svg id="arc" viewBox="0 0 400 220" class="w-full h-auto">
        <!-- Arc path (semi-circle) -->
        <defs>
          <linearGradient id="dayGrad" x1="0" x2="1" y1="0" y2="0">
            <stop offset="0%" stop-color="#fde68a"/>
            <stop offset="50%" stop-color="#fcd34d"/>
            <stop offset="100%" stop-color="#fbbf24"/>
          </linearGradient>
          <linearGradient id="nightGrad" x1="0" x2="1" y1="0" y2="0">
            <stop offset="0%" stop-color="#93c5fd"/>
            <stop offset="50%" stop-color="#60a5fa"/>
            <stop offset="100%" stop-color="#3b82f6"/>
          </linearGradient>
        </defs>

        <path id="arcPath" d="" fill="none" stroke="#e2e8f0" stroke-width="10" stroke-linecap="round" />
        
        <!-- Sunrise / Sunset ticks -->
        <circle id="leftTick"  cx="0" cy="0" r="4" fill="currentColor"/>
        <circle id="rightTick" cx="0" cy="0" r="4" fill="currentColor"/>

        <!-- Sun/Moon marker group -->
        <g id="marker" transform="translate(0,0)">
          <circle id="markerBg" r="14" fill="url(#dayGrad)" stroke="rgba(0,0,0,0.08)" stroke-width="1"/>
          <circle id="moonCut" r="14" fill="white" opacity="0"/>
          <circle id="markerCore" r="6" fill="white"/>
        </g>

        <!-- Labels (drawn with foreignObject fallback to text) -->
        <text id="labelLeft"  x="0" y="0" class="arc-label" text-anchor="start" alignment-baseline="hanging">—</text>
        <text id="labelRight" x="0" y="0" class="arc-label" text-anchor="end"   alignment-baseline="hanging">—</text>
      </svg>
    </div>

    <div id="notice" class="mt-3 text-xs text-amber-700 bg-amber-50 border border-amber-200 rounded-lg p-3 hidden"></div>
  </section>
</main>

<footer class="mt-6 text-center text-xs text-slate-500">
  No APIs. Math only. <span id="srcTag"></span>
</footer>

  </div>  <script>
  ;(() => {
    const $ = (s) => document.querySelector(s)

    // UI refs
    const utcEl = $('#utcTime')
    const tzEl = $('#tzName')
    const fmtToggle = $('#fmtToggle')
    const fmtLabel  = $('#fmtLabel')
    const locLabel  = $('#locLabel')
    const dayState  = $('#dayState');
    const noticeEl  = $('#notice')
    const srcTag    = $('#srcTag')

    // SVG refs
    const arc = $('#arc')
    const arcPath = $('#arcPath')
    const marker = $('#marker')
    const markerBg = $('#markerBg')
    const moonCut = $('#moonCut')
    const leftTick = $('#leftTick')
    const rightTick = $('#rightTick')
    const labelLeft = $('#labelLeft')
    const labelRight = $('#labelRight')

    // Arc geometry
    const W = 400, H = 220
    const cx = 200, cy = 200, r = 160

    // Draw base arc path & ticks once
    const left = { x: cx - r, y: cy }
    const right = { x: cx + r, y: cy }
    const top = { x: cx, y: cy - r }
    arcPath.setAttribute('d', `M ${left.x} ${left.y} A ${r} ${r} 0 0 1 ${right.x} ${right.y}`)
    place(leftTick, left.x, left.y)
    place(rightTick, right.x, right.y)
    placeText(labelLeft, left.x + 6, left.y + 8)
    placeText(labelRight, right.x - 6, right.y + 8)

    function place(el, x, y){ el.setAttribute('cx', x); el.setAttribute('cy', y) }
    function placeText(el, x, y){ el.setAttribute('x', x); el.setAttribute('y', y) }

    // Format pref
    const PREF_KEY = 'utc-clock-12h'
    fmtToggle.checked = localStorage.getItem(PREF_KEY) === '1'
    updateFmtLabel()
    fmtToggle.addEventListener('change', () => {
      localStorage.setItem(PREF_KEY, fmtToggle.checked ? '1' : '0')
      updateFmtLabel(); updateSunLabels(); tick()
    })
    function is12h(){ return fmtToggle.checked }
    function updateFmtLabel(){ fmtLabel.textContent = is12h() ? '12‑hour' : '24‑hour' }

    // Location detection
    const tz = Intl.DateTimeFormat().resolvedOptions().timeZone || 'Local'
    tzEl.textContent = 'UTC'

    const tzMap = {
      // Minimal representative mapping (extend as needed)
      'Asia/Kolkata': [19.0760, 72.8777],
      'Asia/Dubai': [25.2048, 55.2708],
      'Asia/Singapore': [1.3521, 103.8198],
      'Asia/Tokyo': [35.6762, 139.6503],
      'Asia/Shanghai': [31.2304, 121.4737],
      'Asia/Hong_Kong': [22.3193, 114.1694],
      'Asia/Bangkok': [13.7563, 100.5018],
      'Europe/London': [51.5074, -0.1278],
      'Europe/Paris': [48.8566, 2.3522],
      'Europe/Berlin': [52.52, 13.405],
      'Europe/Moscow': [55.7558, 37.6173],
      'Europe/Madrid': [40.4168, -3.7038],
      'Europe/Rome': [41.9028, 12.4964],
      'US/Eastern': [40.7128, -74.0060],
      'America/New_York': [40.7128, -74.0060],
      'America/Chicago': [41.8781, -87.6298],
      'America/Denver': [39.7392, -104.9903],
      'America/Los_Angeles': [34.0522, -118.2437],
      'America/Toronto': [43.6532, -79.3832],
      'America/Mexico_City': [19.4326, -99.1332],
      'America/Sao_Paulo': [-23.5505, -46.6333],
      'America/Santiago': [-33.4489, -70.6693],
      'Africa/Cairo': [30.0444, 31.2357],
      'Africa/Johannesburg': [-26.2041, 28.0473],
      'Australia/Sydney': [-33.8688, 151.2093],
      'Pacific/Auckland': [-36.8485, 174.7633],
      'Etc/UTC': [0,0], 'UTC': [0,0]
    }

    const state = {
      lat: 0, lon: 0, src: 'approx',
      sunrise: null, sunset: null, prevSunset: null, nextSunrise: null,
      polar: null
    }

    detectLocation().then(() => { computeSunTimes(); updateTheme(); updateSunLabels(); tick(); startLoops() })

    function detectLocation(){
      locLabel.textContent = 'Detecting…'
      srcTag.textContent = ''
      return new Promise((resolve) => {
        if (!('geolocation' in navigator)) return fallback()
        const opt = { enableHighAccuracy: false, timeout: 5000, maximumAge: 600000 }
        navigator.geolocation.getCurrentPosition((pos) => {
          const { latitude, longitude } = pos.coords
          Object.assign(state, { lat: latitude, lon: longitude, src: 'gps' })
          locLabel.textContent = `${latitude.toFixed(3)}, ${longitude.toFixed(3)} (GPS)`
          srcTag.textContent = 'Source: GPS'
          resolve()
        }, () => fallback(resolve), opt)
      })
    }

    function fallback(done){
      const ll = tzMap[tz] || approxByOffset()
      Object.assign(state, { lat: ll[0], lon: ll[1], src: ll[2] || 'tz' })
      locLabel.textContent = `${state.lat.toFixed(3)}, ${state.lon.toFixed(3)} (${state.src === 'tz' ? 'TZ guess' : 'approx'})`
      srcTag.textContent = `Source: ${state.src === 'tz' ? 'Time zone guess' : 'Offset approx'}`
      noticeEl.classList.remove('hidden')
      noticeEl.textContent = 'Tip: Allow location for accurate sunrise/sunset.'
      if (done) done()
      else return Promise.resolve()
    }

    function approxByOffset(){
      // Fallback when TZ not mapped: estimate longitude from local offset; latitude ~ 0
      const offsetMin = new Date().getTimezoneOffset() // minutes behind UTC (>0 west)
      const offsetHr = -offsetMin / 60 // hours east of UTC
      const lon = offsetHr * 15
      return [0, lon, 'approx']
    }

    // --- Solar math (NOAA style) ---
    const d2r = (d)=> d * Math.PI / 180
    const r2d = (r)=> r * 180 / Math.PI

    function dayOfYear(date){
      const start = new Date(date.getFullYear(),0,0)
      const diff = date - start
      return Math.floor(diff / 86400000)
    }

    function normalizeDeg(a){ a = a % 360; return a < 0 ? a + 360 : a }

    function sinD(d){ return Math.sin(d2r(d)) }
    function cosD(d){ return Math.cos(d2r(d)) }
    function tanD(d){ return Math.tan(d2r(d)) }
    function acosD(x){ return r2d(Math.acos(x)) }
    function atanD(x){ return r2d(Math.atan(x)) }

    const ZENITH = 90.833 // degrees (−0.833 apparent)

    function sunEventUTC(date, lat, lon, isSunrise){
      const N = dayOfYear(date)
      const lngHour = lon / 15
      const t = N + ((isSunrise ? 6 : 18) - lngHour) / 24
      const M = 0.9856 * t - 3.289
      let L = M + 1.916 * sinD(M) + 0.020 * sinD(2*M) + 282.634
      L = normalizeDeg(L)
      let RA = atanD(0.91764 * tanD(L))
      RA = normalizeDeg(RA)
      const Lquad = Math.floor(L/90) * 90
      const RAquad = Math.floor(RA/90) * 90
      RA = RA + (Lquad - RAquad)
      RA /= 15
      const sinDec = 0.39782 * sinD(L)
      const cosDec = Math.cos(Math.asin(sinDec))
      const cosH = (cosD(ZENITH) - (sinDec * sinD(lat))) / (cosDec * cosD(lat))
      if (cosH > 1) return NaN // never rises
      if (cosH < -1) return -Infinity // never sets (use sentinel)
      let H = isSunrise ? (360 - acosD(cosH)) : acosD(cosH)
      H /= 15
      const T = H + RA - (0.06571 * t) - 6.622
      let UT = T - lngHour
      UT = (UT % 24 + 24) % 24
      return UT
    }

    function buildEventDate(baseLocalDate, UT){
      if (!isFinite(UT)) return null
      const d = new Date(baseLocalDate)
      d.setUTCHours(0,0,0,0)
      // Move to UTC day start, then add UT hours
      const ms = Math.round(UT * 3600 * 1000)
      d.setTime(d.getTime() + ms)
      return d
    }

    function computeSunTimes(){
      const now = new Date()
      const lat = state.lat, lon = state.lon
      const srUT = sunEventUTC(now, lat, lon, true)
      const ssUT = sunEventUTC(now, lat, lon, false)

      // Yesterday & Tomorrow for night spans
      const y = new Date(now); y.setDate(y.getDate()-1)
      const tmr = new Date(now); tmr.setDate(tmr.getDate()+1)
      const prevSS_UT = sunEventUTC(y, lat, lon, false)
      const nextSR_UT = sunEventUTC(tmr, lat, lon, true)

      state.polar = (Number.isNaN(srUT) || !isFinite(ssUT)) ? 'polar-night' :
                    (!isFinite(srUT) || Number.isNaN(ssUT)) ? 'polar-day' : null

      state.sunrise = buildEventDate(now, srUT)
      state.sunset  = buildEventDate(now, ssUT)
      state.prevSunset = buildEventDate(y, prevSS_UT)
      state.nextSunrise = buildEventDate(tmr, nextSR_UT)
    }

    // --- UI updates ---
    function tick(){
      const now = new Date()
      // UTC clock
      utcEl.textContent = formatTime(now, 'UTC', is12h())

      // Marker position + theme label
      const info = semicyclePosition(now)
      moveMarker(info.f, info.dir)
      dayState.textContent = info.label
      updateTheme(info.isDay)
    }

    function startLoops(){
      setInterval(tick, 1000)
      // Refresh solar times every 5 minutes to stay accurate
      setInterval(() => { computeSunTimes(); updateSunLabels(); }, 5*60*1000)
    }

    function formatTime(date, tz, twelve){
      const opt = { hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: twelve, timeZone: tz }
      return new Intl.DateTimeFormat(undefined, opt).format(date)
    }

    function formatHM(date, twelve){
      const opt = { hour: '2-digit', minute: '2-digit', hour12: twelve }
      return new Intl.DateTimeFormat(undefined, opt).format(date)
    }

    function updateSunLabels(){
      const twelve = is12h()
      const now = new Date()

      // Polar cases: hide labels (no conventional rise/set)
      if (state.polar === 'polar-day' || state.polar === 'polar-night'){
        labelLeft.textContent = '—'
        labelRight.textContent = '—'
        return
      }

      // Daytime: left = Sunrise (today), right = Sunset (today)
      if (state.sunrise && state.sunset && now >= state.sunrise && now <= state.sunset){
        labelLeft.textContent  = formatHM(state.sunrise, twelve)
        labelRight.textContent = formatHM(state.sunset,  twelve)
        return
      }

      // Nighttime: left = Sunset (prev or today), right = Sunrise (today or next)
      const afterSunset = state.sunset && now > state.sunset
      const leftEvt  = afterSunset ? state.sunset : state.prevSunset
      const rightEvt = afterSunset ? state.nextSunrise : state.sunrise
      labelLeft.textContent  = leftEvt  ? formatHM(leftEvt,  twelve) : '—'
      labelRight.textContent = rightEvt ? formatHM(rightEvt, twelve) : '—'
    }

    function semicyclePosition(now){
      if (state.polar === 'polar-day') { setMarkerMode(true);  return { f: 0.5, isDay: true, dir: 1,  label: 'Polar Day' } }
      if (state.polar === 'polar-night'){ setMarkerMode(false); return { f: 0.0, isDay: false, dir: -1, label: 'Polar Night' } }
      const sr = state.sunrise, ss = state.sunset
      const prevSS = state.prevSunset, nextSR = state.nextSunrise
      if (sr && ss && now >= sr && now <= ss){
        const f = (now - sr) / (ss - sr)
        setMarkerMode(true)
        return { f: clamp01(f), isDay: true, dir: 1, label: 'Daytime' }
      }
      // Night: choose correct span (prev sunset → sunrise) or (sunset → next sunrise)
      let a = prevSS, b = sr
      if (ss && now > ss) { a = ss; b = nextSR }
      const f = a && b ? (now - a) / (b - a) : 0
      setMarkerMode(false)
      return { f: clamp01(f), isDay: false, dir: -1, label: 'Night' }
    }
      // Night: choose correct span
      let a = prevSS, b = sr
      if (now > ss) { a = ss; b = nextSR }
      const f = a && b ? (now - a) / (b - a) : 0
      setMarkerMode(false)
      return { f: clamp01(f), isDay: false, label: 'Night' }
    }

    function clamp01(x){ return Math.max(0, Math.min(1, x)) }

    function moveMarker(f, dir){
      // Day moves left→right; Night moves right→left by inverting the fraction
      const frac = (dir && dir < 0) ? (1 - f) : f
      const theta = Math.PI * (1 - frac) // left(π) → right(0)
      const x = cx + r * Math.cos(theta)
      const y = cy - r * Math.sin(theta)
      marker.setAttribute('transform', `translate(${x},${y})`)
    }

    function setMarkerMode(isDay){
      if (isDay){
        markerBg.setAttribute('fill', 'url(#dayGrad)')
        moonCut.setAttribute('opacity', '0')
      } else {
        markerBg.setAttribute('fill', 'url(#nightGrad)')
        // Simple moon crescent mask illusion: offset white circle
        moonCut.setAttribute('opacity', '1')
        // Animate a mild phase based on lunar cycle (~29.53 days)
        const phase = lunarPhase()
        const dx = 7 * Math.cos(2*Math.PI*phase)
        moonCut.setAttribute('transform', `translate(${dx},0)`)
      }
    }

    function lunarPhase(){
      // Returns [0,1): 0=new, 0.5=full (approx)
      const now = new Date()
      const synodic = 29.530588853
      const knownNewMoon = Date.UTC(2000,0,6,18,14) // Jan 6 2000 18:14 UTC
      const days = (now.getTime() - knownNewMoon) / 86400000
      const phase = (days % synodic + synodic) % synodic
      return phase / synodic
    }

    function updateTheme(forceDay){
      const isDay = typeof forceDay === 'boolean' ? forceDay : (dayState.textContent === 'Daytime')
      document.body.classList.toggle('bg-slate-900', !isDay)
      document.body.classList.toggle('text-slate-100', !isDay)
      document.body.classList.toggle('bg-slate-100', isDay)
      document.body.classList.toggle('text-slate-900', isDay)
    }
  })()
  </script></body>
</html>
